# Chapter 08 -- 函數 #

* [8.1 簡單的函數範例](#81-簡單的函數範例)
* [8.2 函數的基本架構](#82-函數的基本架構)
* [8.3 簡單的函數範例](#83-更多的函數應用範例)
* [8.4 簡單的函數範例](#84-遞迴函數)
* [8.5 空迴圈](#85-區域全域與靜態變數)
* [8.6 我要使用哪一種迴圈](#86-引述傳遞的機制)
* [8.7 巢狀迴圈](#87-前置處理器--define)
* [8.8 迴圈的跳離](#88-再來看看-include-前置處理器)

## 8.1 簡單的函數範例 ##

* 使用函數的最大目的，就是利用模組化的方式來簡化主程式。

* 基本架構
  * 函數原型的宣告
  * 引述的使用
  * 函數的主體
  * 回傳值
  * ...

## 8.2 函數的基本架構 ##

* 完整函數的撰寫 = 函數原型(prototype)的宣告 + 函數主體的定義

* prototype 宣告的格式
  * 傳回值型態 函數名稱(引述型態1, 引述型態2, ...);

## 8.3 更多的函數應用範例 ##

* 無論程式中呼叫某個函數幾次，該函數所產生的程式碼只會被編譯一次。

## 8.4 遞迴函數 ##

* 遞迴(recursive)就是函數本身呼叫自己。

* 舉例
  * 階層函數(factorial function)
  * 河內塔(hanoi tower)
  * 費式數列(fibonacci)
  * 二元數搜尋法(binary search)
  * 最大公因數(highest common factor，hcf)
  * 十進位轉換成二進位

* 優點
  * 使程式碼變得簡潔。

* 缺點
  * 占用記憶體，存放未執行完畢的部分。
  * 當遞迴函數的層數很大時，就必須要有較大的記憶體。

* 注意事項
  * 一定要有終止條件，使函數得以返回上層呼叫的地方。
  * 並非以遞迴的方式所撰寫的函數執行起來就比較有效率。

## 8.5 區域、全域與靜態變數 ##

* 區域變數(loacl variable)

* 全域變數(global variable)

* 靜態變數(static variable)
  * 在編譯時，就已配置固定的記憶體空間，使靜態變數的值得以保存。
  * 再次呼叫該函數時，會將靜態變數存在記憶體空間中的值取出來用。
  * 作用
    1. 在函數本體內，一個被宣告為靜態的變數，在這一函數被呼叫過程中，其值不變。
    2. 在一個 block 中，一個被宣告為靜態的變數，可以被 block 內的所有函數存取，但不能被 block 外的其他函數存取。是一個本地的全局變量。
    3. 在一個 block 中，一個被宣告為靜態的函數，可以被 block 內的其他函數呼叫，但不能在 block 外被呼叫。

## 8.6 引述傳遞的機制 ##

* 傳值呼叫(call by value):編譯器將欲傳入函數的引數之值另行複製一份，供呼叫的函數使用，不會更改到原先變數的值。

* 傳址呼叫(call by address)

## 8.7 前置處理器 – #define ##

* 以 # 開頭的前置處理指令，是在編譯之前就會先進行處理，再把處理後的結果與程式碼一起送給編譯器編譯。
  1. #include
  2. #define (巨集指令)

* #define 識別名稱 代換標記
  1. 使用識別名稱，替換後面的代換標記
  2. 不可以加分號

* 優點
  1. 增加程式的易讀性，縮短閱讀時間
  2. 定義的識別名稱在編譯前會以常數置換，省下記憶體空間，程式碼執行較有效率。

* 巨集(marco)功能:簡單的函數
  1. 有引數，無引數
  2. trade-off:相較於函數，占用記憶體較多，但程式的執行流程不用移轉，因而程式執行的速度較快。

## 8.8 再來看看 #include 前置處理器 ##
