# Chapter 10 -- 指標 #

* [10.1 指標概述](#101-指標概述)
* [10.2 使用指標變數](#102-使用指標變數)
* [10.3 指標與函數](#103-指標與函數)
* [10.4 指標與一維陣列](#104-指標與一維陣列)
* [10.5 指標與字串](#105-指標與字串)
* [10.6 指向指標的指標 – 雙重指標](#106-指向指標的指標--雙重指標)
* [筆記](#筆記)

## 10.1 指標概述 ##

* 利用 pointer 可以使得 function 在傳遞 array 或 string 時更有效率。

* 在較複雜的資料結構如 linked list 或 binary tree 等，均需要 pointer 的協助才能將資料鏈結再一起。

* 需多 function 需要利用 pointer 來傳達記憶體的訊息，如 malloc() 和 fopen() 。

* 在 printf() 以 16 進位顯示，格式碼需使用 %p 。

* compiler 採用位元組定址法來決定變數的位址。

## 10.2 使用指標變數 ##

* 位元運算子 &

* 依址取值運算子 *

## 10.3 指標與函數 ##

## 10.4 指標與一維陣列 ##

* 指標的算術運算:指標內所存放的位址做加法或減法運算。運算時，針對它所指向之資料型態的大小來處理。

* 陣列名稱是一個 指標常數(pointer constant)，非指標變數，它指向了陣列的位址，我們不能更改陣列名稱的指向。

* 指標常數的值就等於它的位址。

## 10.5 指標與字串 ##

* 字元陣列與指標陣列
  * 字元陣列儲存字串時，可能會造成記憶體浪費。
  * 指標陣列
    * int *ptr[3]: ptr是一個指標陣列，它可以存放3個指向整數的指標

## 10.6 指向指標的指標 – 雙重指標 ##

* 利用雙重指標來表示二為陣列的元素

* 利用指標表示陣列 arr\[m][n] 元素的位址  ，可寫成 \*(arr+m)+n

* 利用指標表示陣列 arr\[m][n] 元素  ，可寫成 \*(*(arr+m)+n)

* arr\[0][0] 的值若以指標來表示，可以寫成 **num 。

## 筆記 ##

* 兩個數字交換方法
  * 使用額外一個變數
  * 加減法運算
  * 位元運算
  * 使用 define

* 比較 sizeof()
  * char str1[] = "hello";
    * sizeof(str1):6 ，結尾加上字串結數字元「\0」
  * char str2[10] = "hello";
    * sizeof(str2):10 ，即 初始化 的大小，有包含字串結數字元「\0」
    * 造成記憶體浪費
  * char str3[] = {'h','e','l','l','o'};
    * sizeof(str3):5 ，結尾未加上字串結數字元「\0」
    * 無造成記憶體浪費
  * char str4[10] = {'h','e','l','l','o'};
    * sizeof(str4):10 ，即 初始化 的大小，無字串結數字元「\0」
    * 造成記憶體浪費
  * int str5[] = {1,1,1,1,1};
    * sizeof(str5):20
  * int str6[10] = {1,1,1,1,1};
    * sizeof(str6):40
    * 造成記憶體浪費
  * char *ptr1 = "hello";
    * sizeof(ptr1):8 ， 即 指針 的大小

* \*ptr++ 相當於 *(ptr++)
  * ++ 的優先順序高於 *

* 指標變數建立字串 的走訪
  * while(*ptr != '\0'){}
  * for(int i = 0; *(ptr + i) != '\0'; i++){}
