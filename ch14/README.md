# Chapter 14 -- 動態記憶體配置與鏈結串列 #

* [14.1 動態記憶體配置](#141-動態記憶體配置)
* [14.2 鏈結串列](#142-鏈結串列)
* [14.3 鏈結串列的操作](#143-鏈結串列的操作)
* [note](#note)

## 14.1 動態記憶體配置 ##

* 在程式執行時期(run-time)，可以像系統要求記憶空間，當記憶空間不在使用時，可以將空間歸還給系統。

* malloc()
  * 指標變數 = (指標變數所指向的型態 *) malloc(所需記憶體空間);
    * int *ptr = (\*int) malloc (3\*sizeof(int));
  * 會傳回所配置記憶體的位址，所以必須以指標接收它

* free()
  * 透過 malloc() 所分配出來的空間必須呼叫 free() 才能歸還給系統
  * 如果未歸還記憶體，可能會造成程式佔用太多記憶體，此現象稱為記憶體洩漏(memory leakage)
  * 如果已歸還記憶體，卻仍嘗試去使用，則會發生記憶空間分割失敗(segmentation fault)的錯誤。

## 14.2 鏈結串列 ##

* 有次序的資訊稱為串列 (list)

* 若存放串列元素的記憶體是循序的，則此串列稱為循序串列(sequential list)；若存放串列元素的記憶體並不連續，而必須以指標將他們鏈結起來，則稱為鏈結串列(linked list)

* 鏈結串列是由節點(Node)所組成，而每個節點是採用動態記憶體配置的方式來配置記憶空間給它們

* Node 包含兩個成員，第一個成員是該節點所儲存的資料，第二個成員則是指標，它指向下一個節點的位址

* 終端節點已是最後一個節點，所以將第二個成員，亦即指標設成 NULL

* 由於鏈結串列的每一個 Node 在記憶體中的位置不是連續的，所以如果要截取或修改某個節點的內容，必須從第一個元素開始，依鏈結的指標依序往後找尋，直到找到該節點為址

* 如果是要刪除或插入串列中的某個節點，因為只需要更改指標的址向，所以花費的時間較為固定，同時也較循序串列所花的時間短

## 14.3 鏈結串列的操作 ##

* 常用的操作
  * 建立 create
  * 列印 print、走訪 traverse
  * 插入 insert
    * 插入至第一個
    * 插入至串列中
  * 刪除 delete
    * 串列為空，不進行刪除
    * 刪除串列第一個
    * 刪除串列中任意一個
  * 搜尋 search
  * 釋放 free

## note ##

* 記憶體配置方式 (memory allocation)
  * 靜態 (static memory allocation)
    * 在編譯階段就配置好記憶體
    * 容易造成記憶體浪費
  * 動態 (dynamic memory allocation)
    * 程式執行階段視實際需求來配置記憶空間

* scanf 輸入時，buffer 處理
  * 在%c前面加上一個空格
    * scanf(" %c", &ch);
  * 清空緩衝區內的資料
    * fflush(stdin);
  * 吸收空格這個字元
    * getchar();

* 學習順序
  * 陣列
  * 結構
  * 結構陣列
  * 動態記憶體配置
  * 鏈結串列 + 靜態記憶體配址
  * 鏈結串列 + 動態記憶體配置
